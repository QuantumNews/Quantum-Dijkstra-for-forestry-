# -*- coding: utf-8 -*-
"""MS_Azure Test_IonQ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QHDMPmznFhrmpkv4qAHKdrxJnsLzhtmJ
"""

!pip install 'azure-quantum[qiskit]'

!pip install azure.quantum

from azure.quantum import Workspace
workspace = Workspace (
    resource_id = "/subscriptions/d81c0334-403f-4448-bb14-27c85215891b/resourceGroups/AzureQuantum/providers/Microsoft.Quantum/Workspaces/GHG", # Add your resource_id
    location = "West US"  # Add your workspace location (for example, "westus")
)

from qiskit import QuantumCircuit
from qiskit.visualization import plot_histogram
from qiskit.tools.monitor import job_monitor
from azure.quantum.qiskit import AzureQuantumProvider

provider = AzureQuantumProvider(workspace)

# Show all backends:
print(provider.backends())
#[<IonQSimulatorBackend('ionq_simulator')>, <IonQQPUBackend('ionq_qpu')>]#

# Get IonQ quantum simulator target:
simulator_backend = provider.get_backend("ionq.simulator")

"""randon graph/network"""

import networkx as nx
import matplotlib.pyplot as plt
import random

def generate_graph(nodes, num_vertices):
    G = nx.Graph()

    # Randomly choose a starting node
    start_node = random.choice(nodes)

    # Add starting node and set a different color
    G.add_node(start_node, color='red')

    # Add other nodes and edges
    for _ in range(num_vertices):
        end_node = f'Node_{len(G.nodes) + 1}'
        G.add_node(end_node)
        G.add_edge(start_node, end_node)

    return G

def visualize_graph(graph):
    pos = nx.spring_layout(graph)
    node_colors = [data['color'] if 'color' in data else 'skyblue' for node, data in graph.nodes(data=True)]
    nx.draw(graph, pos, with_labels=True, node_size=700, node_color=node_colors, font_size=8, font_color="black", font_weight="bold")
    plt.show()

# List of nodes
node_list = ['A', 'B', 'C', 'D', 'E']

# Generate and visualize the graph with a randomly chosen starting node and 20 vertices
graph = generate_graph(node_list, num_vertices=20)
#isualize_graph(graph)

import networkx as nx
import random

def generate_graph_with_weights(nodes, num_vertices):
    G = nx.Graph()

    # Randomly choose a starting node
    start_node = random.choice(nodes)

    # Add starting node and set a different color
    G.add_node(start_node, color='red')

    # Add other nodes, edges, and weights
    weights_list = []
    for _ in range(num_vertices):
        end_node = f'Node_{len(G.nodes) + 1}'
        weight = random.randint(1, 99)  # Random integer between 1 and 99
        weights_list.append(weight)
        G.add_node(end_node)
        G.add_edge(start_node, end_node, weight=weight)

    return G, weights_list

# List of nodes
node_list = ['A', 'B', 'C', 'D', 'E']

# Generate the graph with weights and get the weights list
graph, weights_list = generate_graph_with_weights(node_list, num_vertices=20)
visualize_graph(graph)

# Print the list of weights
print("List of Weights:", weights_list)

from qiskit import QuantumCircuit
from math import log2

def create_smallest_item_oracle(n, weights_list):
    qc = QuantumCircuit(n + 1, n)

    # Apply Hadamard gates to all qubits
    qc.h(range(n + 1))

    # Find the index of the smallest item in the list
    smallest_index = weights_list.index(min(weights_list))

    # Convert the index to its binary representation
    binary_representation = format(smallest_index, f'0{n}b')[::-1]

    # Apply a phase inversion on the corresponding qubits
    for i, bit in enumerate(binary_representation):
        if bit == '1':
            qc.z(i)

    # Apply Hadamard gates again
    qc.h(range(n + 1))

    # Measure all qubits except the auxiliary qubit
    qc.measure(range(n), range(n))

    return qc

# Determine the number of qubits based on the list size
n_qubits = int(log2(len(weights_list)))

# Create the oracle that performs a phase inversion on the state corresponding
# to the index of the smallest item in the list
smallest_item_oracle = create_smallest_item_oracle(n_qubits, weights_list)

# Print the weights list and the quantum circuit
print("Weights List:", weights_list)
print(smallest_item_oracle)

from qiskit import Aer, transpile, assemble
from qiskit.visualization import plot_histogram

# Define the backend simulator
simulator_backend = provider.get_backend("ionq.qpu.aria-1")

# Transpile the quantum circuit for the simulator
transpiled_circuit = transpile(smallest_item_oracle, simulator_backend)

# Assemble the transpiled circuit for the simulator
qobj = assemble(transpiled_circuit)

# Run the simulation
result = simulator_backend.run(qobj).result()

# Get the counts from the result
counts = result.get_counts()

# Find the most probable state
most_probable_state = max(counts, key=counts.get)

# Convert the binary representation to decimal
decimal_value = int(most_probable_state[::-1], 2)

# Print the most probable state as a decimal value
print("Most Probable State (Decimal):", decimal_value)

# Get all possible states
all_possible_states = [format(i, f'0{n_qubits}b')[::-1] for i in range(2**n_qubits)]

# Create a dictionary with all possible states and set counts to 0 for states that didn't occur
counts_all_states = {state: counts.get(state, 0) for state in all_possible_states}

# Plot the histogram with all possible states on the x-axis
plot_histogram(counts_all_states)

import json
import matplotlib.pyplot as plt

# JSON output from the IonQ quantum computer
ionq_output = '{"histogram":{"15": 0.9629268292682926, "14": 0.010731707317073172, "13": 0.011707317073170732, "11": 0.00975609756097561, "7": 0.004878048780487805}}'

# Parse the JSON output
data = json.loads(ionq_output)
histogram_data = data['histogram']

# Convert keys to binary representation
binary_keys = [format(int(key), '04b') for key in histogram_data.keys()]

# Plot the histogram
plt.bar(binary_keys, histogram_data.values())
plt.xlabel('Measured State (Binary)')
plt.ylabel('Probabilities')
plt.title('Histogram of Measurement Probabilities')
plt.show()